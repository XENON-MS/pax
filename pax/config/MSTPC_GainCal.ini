# This configuration file is adapted from XENON100.ini for the Münster TPC
# It will contain MünsterTPC-specific details
# date: Aug 26th 2015
# editor : Axel Buß

# This config contains the gain calibrated values of Julian B.'s measurements with a green LED at room temperature
[pax]
parent_configuration = "_base"
plugin_paths = ['examples/muenster']

input = 'EVE_file.EveInput'
#show_waveforms = ['ShowWaveforms.PlotAllChannels']
#output = 'Plotting.PlotEventSummary'
# Global settings, passed to every plugin
dsp = [
            # Do some sanity checks / cleaning on pulses
            #'CheckPulses.SortPulses',
            'CheckPulses.ConcatenateAdjacentPulses',
            'CheckPulses.CheckBounds',

            # Find individual hits
            'HitFinder.FindHits',
            # Combine hits into rough clusters = peaks
      #'BuildPeaks.GapSizeClustering',

            # Reject hits in noisy channels
      #'RejectNoiseHits.RejectNoiseHits',
      #'SumWaveform.SumWaveform',  # Must do this AFTER noisy hit rejection!



            # Compute sum-waveform and hit-dependent properties for each peak
            'BasicProperties.BasicProperties',
      #'BasicProperties.SumWaveformProperties',
      # 'BasicProperties.CountCoincidentNoisePulses'
        ]

# Compute peak properties: can be redone from processed data file
compute_properties = [
#                        'WeightedSum.PosRecWeightedSum',
#                        'MaxPMT.PosRecMaxPMT',
#                        'RobustWeightedMean.PosRecRobustWeightedMean',
#                        'NeuralNet.PosRecNeuralNet',
#                        'ChiSquareGamma.PosRecChiSquareGamma',
#                        'HitpatternSpread.HitpatternSpread',
                     ]

# Final stage with 'risky' operations: peak classification, S1/S2 pairing, corrections
# Intentionally last, so reclassification takes least work
pre_analysis = [
                # Classify the clusters based on the properties
               #'ClassifyPeaks.AdHocClassification',

                # Combine S1 and S2 into pairs = interactions and compute properties
                # which depend on S1 AND S2 specific information (i.e. z-corrections)
#                'BuildInteractions.BuildInteractions',
#                'BuildInteractions.BasicInteractionProperties',
               ]
pre_output = []
#output = 'ROOTClass.WriteROOTClass'
output = 'Table.TableWriter'

[DEFAULT]
tpc_name = "MuensterTPC"



# Time in the event at which trigger occurs. Set to None or leave out if there is no trigger
trigger_time_in_event = 2560 * ns    # Check settings in caen1724.par

pmt_0_is_fake = False      # TODO

# Detector specification
# PlotChannelWaveform2D expects the detector names' lexical order to be the same as the channel order
channels_in_detector = {
                       'tpc':   [0, 1, 2, 3, 4, 5, 6,
                                 7, 8, 9, 10, 11, 12, 13]
                       }
n_channels = 14    # 2x v1724

# PMT numbers for tpc, specified as lists

channels_bottom = [0, 1, 2, 3, 4, 5, 6]
channels_top = [7, 8, 9, 10, 11, 12, 13]

# PMT locations taken from technical drawing of Muenster TPC
# Whether they are in correct order has to be confirmed yet
# Note: don't forget the units...
tpc_length = 17 * cm
tpc_radius = 4 * cm
pmt_locations = [
                {'x':  -2.900 * cm, 'y':  -1.450 * cm},  # 0 ↓↓↓ bottom ↓↓↓
                {'x':  -2.900 * cm, 'y':  +1.450 * cm},  # 1
                {'x':   0.000 * cm, 'y':  +2.900 * cm},  # 2
                {'x':   0.000 * cm, 'y':   0.000 * cm},  # 3
                {'x':   0.000 * cm, 'y':  -2.900 * cm},  # 4
                {'x':   2.900 * cm, 'y':  -1.450 * cm},  # 5
                {'x':   2.900 * cm, 'y':   1.450 * cm},  # 6
                {'x':  -2.900 * cm, 'y':  -1.450 * cm},  # 7 ↓↓↓ top ↓↓↓
                {'x':  -2.900 * cm, 'y':  +1.450 * cm},  # 8
                {'x':   0.000 * cm, 'y':  +2.900 * cm},  # 9
                {'x':   0.000 * cm, 'y':   0.000 * cm},  # 10
                {'x':   0.000 * cm, 'y':  -2.900 * cm},  # 11
                {'x':   2.900 * cm, 'y':  -1.450 * cm},  # 12
                {'x':   2.900 * cm, 'y':   1.450 * cm},  # 13
                ]




# These gains are placeholder for gain calibration
gains = [1] * 14

gain_sigmas = [0.5] * 14

[EVE_file.EveInput]
Channel_to_PMT_mapping =
{0 : 0,
1 : 1,
2 : 2,
3 : 3,
4 : 4,
5 : 5,
6 : 6,
7 : 7,
8 : 8,
9 : 9,
10 : 10,
11 : 11,
12 : 12,
14 : 13}



[Plotting]
waveforms_to_plot = (
                    {'internal_name': 'tpc',      'plot_label': 'TPC (hits only)',
                    'drawstyle': 'steps',         'color':'black'},
                    )
[HitFinder.FindHits]
make_diagnostic_plots = "never"
# Compute baseline on first n samples in pulse:
initial_baseline_samples = 40   # When using ZLE this must not be higher than 2x zle_nlbk as the peaks will be counted in otherwise
height_over_noise_high_threshold = 3
height_over_noise_low_threshold = 1

[Cluster]
# Suspicious channel rejection settings
penalty_per_noise_pulse = 1                 # "pe" equivalent penalty
penalty_per_lone_hit = 1                    # "pe" equivalent penalty
# Threshold to mark a suspicious channel
penalty_geq_this_is_suspicious = 3          # "pe" equivalent penalty

# If the ratio of noise channels / contributing channels is larger than this, classify peak as 'noise'
# noise channel = a channel in the same detector which shows data, but doesn't contribute to the peak
# (or only hits rejected by the suspicious channel algorithm)
max_noise_channels_over_contributing_channels = 2

[Cluster.MeanShift]
s2_size = 20
# If spe peaks are separated by less than this, they will be clustered together
s2_width = 1.0 * us
p_value = 0.999
cluster_all = True

[Cluster.HitDifference]
max_difference = 2 * ns

[BuildPeaks.GapSizeClustering]
# Start a new cluster / peak if a gap larger than this is encountered
# see [note tbd]
max_gap_size_in_cluster = 10 * ns

[RejectNoiseHits]
# Suspicious channel rejection settings
penalty_per_noise_pulse = 0                 # "pe" equivalent penalty
penalty_per_lone_hit = 1                    # "pe" equivalent penalty

# Threshold to mark a suspicious channel
penalty_geq_this_is_suspicious = 3          # "pe" equivalent penalty

# Very dodgy channels start with a base penalty to make them always suspicious
# This means they will contribute only if non-suspicious channels in the same detector show > 3pe area
# Dodgy channels selected using run 10 noisy AmBe (120402_2000)
base_penalties = {
                 }


[Table.TableWriter]
#output_format = 'hdf5_pandas'      # hdf5, csv, numpy, html, json, root, hdf5_pandas
# Don't leave out hits and pulses -- that's what we're after!
fields_to_ignore = ['sum_waveforms',
                   'channel_waveforms',
                   #'all_hits',
                   'raw_data',
                   'hits',
                   #'peaks',
                   #'pulses',
                   'detector',
                   'n_reconstructed_positions',
                   'reconstructed_positions_start',
                   'area_fraction_top',
                   'area_midpoint',
                   'area_per_channel',
                   'birthing_split_fraction',
                   'birthing_split_goodness',
                   'bottom_hitpattern_spread',
                   'hit_time_mean',
                   'hit_time_std',
                   'hits_fraction_top',
                   'interior_split_fraction',
                   'interior_split_goodness',
                   'left',
                   'lone_hit_channel',
                   'mean_amplitude_to_noise',
                   'n_hits',
                   'n_noise_pulses',
                   'n_saturated_channels',
                   'n_saturated_per_channel',
                   'n_saturated_samples',
                   'range_area_decile',
                   'right',
                   'sum_waveform',
                   'sum_waveform_top',
                   'top_hitpattern_spread',
                   ]

[WaveformSimulator]
s2_patterns_file = None
